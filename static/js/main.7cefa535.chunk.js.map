{"version":3,"sources":["styles/mui_theme.js","components/grid/node/node.js","algorithms/bfs.js","algorithms/maze_gen.js","components/grid/grid.js","components/navstrip/navstrip.js","components/App.js","index.js"],"names":["theme","createMuiTheme","overrides","MuiButton","root","margin","padding","palette","primary","light","main","dark","contrastText","secondary","status","danger","Node","this","props","row","col","isStart","isTarget","isWall","onMouseDown","onMouseEnter","onMouseUp","type","id","className","React","Component","bfs","grid","startNode","targetNode","visitedNodes","queue","dirs","push","isVisited","length","size","i","node","shift","j","d","nr","nc","previousNode","genRandomMaze","rows","cols","start","target","walls","probability","GLOBAL_GRID","genRecursiveMaze","getBlankGrid","console","log","divide","x","y","width","height","wx","wy","randInt","px","py","len","nx","ny","w","h","n","Math","random","max","floor","Grid","getNewEndpoints","start_row","start_col","target_row","target_col","state","mouseIsPressed","algorithm","genInitialGrid","setState","newGrid","toggleWall","getNewGrid","nodes","shortestOrder","setTimeout","animateShortestPath","document","getElementById","visited","order","current","unshift","getShortestPath","animateBFS","getMaze","Button","variant","color","onClick","resetGrid","generateMaze","visualize","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","createNode","getRandomInt","TOTAL_ROWS","TOTAL_COLS","getEmptyNode","slice","newNode","min","ceil","App","ThemeProvider","ReactDOM","render"],"mappings":"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","file":"static/js/main.7cefa535.chunk.js","sourcesContent":["import { createMuiTheme } from '@material-ui/core/styles'\nimport orange from '@material-ui/core/colors/orange'\nimport green from '@material-ui/core/colors/green'\n\nexport const theme = createMuiTheme({\n\toverrides: {\n\t\tMuiButton: {\n\t\t\troot: {\n\t\t\t\tmargin: '10px',\n\t\t\t\tpadding: '10px'\n\t\t\t}\n\t\t}\n\t},\n\tpalette: {\n\t\tprimary: {\n\t\t\tlight: '#62d2a2',\n\t\t\tmain: '#62d2a2',\n\t\t\tdark: '#62d2a2',\n\t\t\tcontrastText: '#eeeeee'\n\t\t},\n\t\tsecondary: {\n\t\t\tlight: '#e84a5f',\n\t\t\tmain: '#e84a5f',\n\t\t\tdark: '#e84a5f',\n\t\t\tcontrastText: '#eeeeee'\n\t\t}\n\t},\n\tstatus: {\n\t\tdanger: 'orange'\n\t}\n})\n","import React from 'react'\nimport './node.css'\n\nclass Node extends React.Component {\n\trender() {\n\t\tconst {\n\t\t\trow,\n\t\t\tcol,\n\t\t\tisStart,\n\t\t\tisTarget,\n\t\t\tisWall,\n\t\t\tonMouseDown,\n\t\t\tonMouseEnter,\n\t\t\tonMouseUp\n\t\t} = this.props\n\t\tconst type = isWall\n\t\t\t? 'wall'\n\t\t\t: isStart\n\t\t\t? 'node-start'\n\t\t\t: isTarget\n\t\t\t? 'node-target'\n\t\t\t: 'node-empty'\n\t\treturn (\n\t\t\t<td\n\t\t\t\tid={`node-${row}-${col}`}\n\t\t\t\tclassName={`node ${type}`}\n\t\t\t\tonMouseDown={() => onMouseDown(row, col)}\n\t\t\t\tonMouseEnter={() => onMouseEnter(row, col)}\n\t\t\t\tonMouseUp={() => onMouseUp()}\n\t\t\t></td>\n\t\t)\n\t}\n}\n\nexport default Node\n","export function bfs(grid, startNode, targetNode) {\n\tconst visitedNodes = []\n\tlet queue = []\n\tconst dirs = [\n\t\t[0, 1],\n\t\t[0, -1],\n\t\t[1, 0],\n\t\t[-1, 0]\n\t]\n\tqueue.push(startNode)\n\tstartNode.isVisited = true\n\twhile (queue.length > 0) {\n\t\tlet size = queue.length\n\t\tfor (let i = 0; i < size; ++i) {\n\t\t\tlet node = queue.shift()\n\t\t\tfor (let j = 0; j < dirs.length; ++j) {\n\t\t\t\tconst d = dirs[j]\n\t\t\t\tlet nr = d[0] + node.row\n\t\t\t\tlet nc = d[1] + node.col\n\t\t\t\tif (nr < 0 || nc < 0 || nr >= grid.length || nc >= grid[0].length)\n\t\t\t\t\tcontinue\n\t\t\t\tif (grid[nr][nc].isWall) continue\n\t\t\t\tif (grid[nr][nc].isVisited) continue\n\t\t\t\tif (nr == targetNode.row && nc == targetNode.col) {\n\t\t\t\t\tgrid[nr][nc].previousNode = grid[node.row][node.col]\n\t\t\t\t\tvisitedNodes.push(grid[nr][nc])\n\t\t\t\t\treturn visitedNodes\n\t\t\t\t}\n\t\t\t\tgrid[nr][nc].isVisited = true\n\t\t\t\tgrid[nr][nc].previousNode = grid[node.row][node.col]\n\t\t\t\tvisitedNodes.push(grid[nr][nc])\n\t\t\t\tqueue.push(grid[nr][nc])\n\t\t\t}\n\t\t}\n\t}\n\treturn visitedNodes\n}\n\nexport function dfs(grid, startNode, targetNode) {\n\tconst visitedNodes = []\n\tlet stack = []\n\tconst dirs = [\n\t\t[0, 1],\n\t\t[0, -1],\n\t\t[1, 0],\n\t\t[-1, 0]\n\t]\n\tstack.push(startNode)\n\tstartNode.isVisited = true\n\twhile (stack.length > 0) {\n\t\tlet size = stack.length\n\t\tfor (let i = 0; i < size; ++i) {\n\t\t\tlet node = stack.pop()\n\t\t\tfor (let j = 0; j < dirs.length; ++j) {\n\t\t\t\tconst d = dirs[j]\n\t\t\t\tlet nr = d[0] + node.row\n\t\t\t\tlet nc = d[1] + node.col\n\t\t\t\tif (nr < 0 || nc < 0 || nr >= grid.length || nc >= grid[0].length)\n\t\t\t\t\tcontinue\n\t\t\t\tif (grid[nr][nc].isWall) continue\n\t\t\t\tif (grid[nr][nc].isVisited) continue\n\t\t\t\tif (nr == targetNode.row && nc == targetNode.col) {\n\t\t\t\t\tgrid[nr][nc].previousNode = grid[node.row][node.col]\n\t\t\t\t\tvisitedNodes.push(grid[nr][nc])\n\t\t\t\t\treturn visitedNodes\n\t\t\t\t}\n\t\t\t\tgrid[nr][nc].isVisited = true\n\t\t\t\tgrid[nr][nc].previousNode = grid[node.row][node.col]\n\t\t\t\tvisitedNodes.push(grid[nr][nc])\n\t\t\t\tstack.push(grid[nr][nc])\n\t\t\t}\n\t\t}\n\t}\n\treturn visitedNodes\n}\n\nexport function getShortestPath(target) {\n\tconst order = []\n\tlet current = target\n\twhile (current !== null) {\n\t\tconsole.log('tree')\n\t\tconsole.log(current.previousNode)\n\t\torder.unshift(current)\n\t\tcurrent = current.previousNode\n\t}\n\treturn order\n}\n","export function genRandomMaze(rows, cols, start, target) {\n\tconst walls = []\n\tfor (let i = 0; i < rows; ++i) {\n\t\tconst row = []\n\t\tfor (let j = 0; j < cols; ++j) {\n\t\t\tif (\n\t\t\t\t(i == start[0] && j == start[1]) ||\n\t\t\t\t(i == target[0] && j == target[1])\n\t\t\t) {\n\t\t\t\trow.push(1)\n\t\t\t} else {\n\t\t\t\trow.push(probability(0.2))\n\t\t\t}\n\t\t}\n\t\twalls.push(row)\n\t}\n\treturn walls\n}\n\nfunction getBlankGrid(rows, cols) {\n\tconst grid = []\n\tfor (let i = 0; i < rows; ++i) {\n\t\tconst row = []\n\t\tfor (let j = 0; j < cols; ++j) {\n\t\t\trow.push(0)\n\t\t}\n\t\tgrid.push(row)\n\t}\n\treturn grid\n}\n\nvar GLOBAL_GRID = []\n\nexport function genRecursiveMaze(rows, cols, start, target) {\n\tGLOBAL_GRID = getBlankGrid(rows, cols)\n\tconsole.log(GLOBAL_GRID)\n\tdivide(0, 0, cols, rows)\n\treturn GLOBAL_GRID\n}\n\nfunction divide(x, y, width, height) {\n\tif (width < 2 || height < 2) return\n\n\tvar wx = x + 0\n\tvar wy = y + randInt(height - 2)\n\n\tvar px = wx + randInt(width)\n\tvar py = wy + 0\n\n\tvar dx = 1\n\tvar dy = 0\n\n\tvar len = width\n\tvar dir = 1\n\n\tfor (let i = 0; i < len; ++i) {\n\t\tif (wx != px || wy != py) {\n\t\t\tconsole.log(wy + ' -- ' + wx)\n\t\t\tGLOBAL_GRID[wy][wx] |= dir\n\t\t}\n\t\twx += dx\n\t\twy += dy\n\t}\n\n\tvar nx = x\n\tvar ny = y\n\tvar w = width\n\tvar h = wy - y + 1\n\tdivide(nx, ny, w, h)\n\tconsole.log('BENCHMARK')\n\tnx = x\n\tny = wy + 1\n\tw = w\n\th = y + height - wy - 1\n\tdivide(nx, ny, w, h)\n}\n\nvar probability = function(n) {\n\treturn !!n && Math.random() <= n\n}\n\nfunction randInt(max) {\n\treturn Math.floor(Math.random() * Math.floor(max))\n}\n","import React from 'react'\nimport Node from './node/node'\nimport { Button } from '@material-ui/core'\nimport { dfs, bfs, getShortestPath } from '../../algorithms/bfs'\nimport './grid.css'\nimport { genRandomMaze, genRecursiveMaze } from '../../algorithms/maze_gen'\n\nexport const TOTAL_ROWS = 30\nexport const TOTAL_COLS = 60\n\nconst SPEED_MULTIPLIER = 5\nconst PATH_SPEED_MULTIPLIER = 40\n\nclass Grid extends React.Component {\n\tconstructor() {\n\t\tsuper()\n\t\tconst { start_row, start_col, target_row, target_col } = getNewEndpoints()\n\n\t\tthis.state = {\n\t\t\tstart: [start_row, start_col],\n\t\t\ttarget: [target_row, target_col],\n\t\t\tgrid: [],\n\t\t\tmouseIsPressed: false,\n\t\t\talgorithm: bfs\n\t\t}\n\t}\n\n\tcomponentDidMount() {\n\t\tconst { start, target } = this.state\n\t\tconst grid = genInitialGrid(start, target)\n\t\tthis.setState({ grid: grid })\n\t}\n\n\thandleMouseDown(row, col) {\n\t\tconst { start, target } = this.state\n\t\tif (\n\t\t\t(row == start[0] && col == start[1]) ||\n\t\t\t(row == target[0] && col == target[1])\n\t\t)\n\t\t\treturn\n\t\tconst newGrid = toggleWall(this.state.grid, row, col)\n\t\tthis.setState({ grid: newGrid, mouseIsPressed: true })\n\t}\n\n\thandleMouseEnter(row, col) {\n\t\tif (!this.state.mouseIsPressed) return\n\t\tconst { start, target } = this.state\n\t\tif (\n\t\t\t(row == start[0] && col == start[1]) ||\n\t\t\t(row == target[0] && col == target[1])\n\t\t)\n\t\t\treturn\n\t\tconst newGrid = toggleWall(this.state.grid, row, col)\n\t\tthis.setState({ grid: newGrid })\n\t}\n\n\thandleMouseUp() {\n\t\tthis.setState({ mouseIsPressed: false })\n\t}\n\n\tresetGrid() {\n\t\tconst { start_row, start_col, target_row, target_col } = getNewEndpoints()\n\t\tconst grid = getNewGrid([start_row, start_col], [target_row, target_col])\n\n\t\tthis.setState({\n\t\t\tgrid: grid,\n\t\t\tstart: [start_row, start_col],\n\t\t\ttarget: [target_row, target_col]\n\t\t})\n\t}\n\n\tanimateBFS(nodes, shortestOrder) {\n\t\tfor (let i = 0; i <= nodes.length; ++i) {\n\t\t\tif (i === nodes.length) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.animateShortestPath(shortestOrder)\n\t\t\t\t}, SPEED_MULTIPLIER * i)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (i == nodes.length - 1) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tconst node = nodes[i]\n\t\t\tconsole.log('test')\n\t\t\tsetTimeout(() => {\n\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t'node node-visited'\n\t\t\t}, SPEED_MULTIPLIER * i)\n\t\t}\n\t}\n\n\tanimateShortestPath(shortestOrder) {\n\t\tfor (let i = 0; i < shortestOrder.length; i++) {\n\t\t\tif (i == 0 || i == shortestOrder.length - 1) continue\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst node = shortestOrder[i]\n\t\t\t\tdocument.getElementById(`node-${node.row}-${node.col}`).className =\n\t\t\t\t\t'node node-shortest-path'\n\t\t\t}, PATH_SPEED_MULTIPLIER * i)\n\t\t}\n\t}\n\n\tvisualize() {\n\t\tconst { grid, start, target, algorithm } = this.state\n\t\tconst startNode = grid[start[0]][start[1]]\n\t\tconst targetNode = grid[target[0]][target[1]]\n\t\tconst visited = algorithm(grid, startNode, targetNode)\n\t\tconst shortestOrder = getShortestPath(visited[visited.length - 1])\n\t\tthis.animateBFS(visited, shortestOrder)\n\t}\n\n\tgenerateMaze(algorithm) {\n\t\tconst { start, target } = this.state\n\n\t\tconst grid = getMaze(start, target, algorithm)\n\n\t\tthis.setState({\n\t\t\tgrid: grid\n\t\t})\n\t}\n\n\tgenRecursiveMaze() {}\n\n\trender() {\n\t\tconst { grid } = this.state\n\t\treturn (\n\t\t\t<div className='container'>\n\t\t\t\t<Button\n\t\t\t\t\tvariant='contained'\n\t\t\t\t\tcolor='secondary'\n\t\t\t\t\tonClick={() => this.resetGrid()}\n\t\t\t\t>\n\t\t\t\t\treset\n\t\t\t\t</Button>\n\n\t\t\t\t<Button\n\t\t\t\t\tvariant='contained'\n\t\t\t\t\tcolor='secondary'\n\t\t\t\t\tonClick={() => this.generateMaze(genRandomMaze)}\n\t\t\t\t>\n\t\t\t\t\tgenerate random maze\n\t\t\t\t</Button>\n\t\t\t\t<Button\n\t\t\t\t\tvariant='contained'\n\t\t\t\t\tcolor='secondary'\n\t\t\t\t\tonClick={() => this.generateMaze(genRecursiveMaze)}\n\t\t\t\t>\n\t\t\t\t\tgenerate recursive maze\n\t\t\t\t</Button>\n\t\t\t\t<Button\n\t\t\t\t\tvariant='contained'\n\t\t\t\t\tcolor='primary'\n\t\t\t\t\tonClick={() => this.visualize()}\n\t\t\t\t>\n\t\t\t\t\tstart\n\t\t\t\t</Button>\n\t\t\t\t<table id='board' className='grid'>\n\t\t\t\t\t{grid.map((row, rowIdx) => {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<tr key={rowIdx}>\n\t\t\t\t\t\t\t\t{row.map((node, nodeIdx) => {\n\t\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\t\t\t\tcol,\n\t\t\t\t\t\t\t\t\t\tisStart,\n\t\t\t\t\t\t\t\t\t\tisTarget,\n\t\t\t\t\t\t\t\t\t\tisVisited,\n\t\t\t\t\t\t\t\t\t\tisWall\n\t\t\t\t\t\t\t\t\t} = node\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t<Node\n\t\t\t\t\t\t\t\t\t\t\trow={row}\n\t\t\t\t\t\t\t\t\t\t\tcol={col}\n\t\t\t\t\t\t\t\t\t\t\tkey={nodeIdx}\n\t\t\t\t\t\t\t\t\t\t\tisStart={isStart}\n\t\t\t\t\t\t\t\t\t\t\tisTarget={isTarget}\n\t\t\t\t\t\t\t\t\t\t\tisVisited={isVisited}\n\t\t\t\t\t\t\t\t\t\t\tisWall={isWall}\n\t\t\t\t\t\t\t\t\t\t\tonMouseDown={(row, col) => this.handleMouseDown(row, col)}\n\t\t\t\t\t\t\t\t\t\t\tonMouseEnter={(row, col) =>\n\t\t\t\t\t\t\t\t\t\t\t\tthis.handleMouseEnter(row, col)\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tonMouseUp={() => this.handleMouseUp()}\n\t\t\t\t\t\t\t\t\t\t></Node>\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t)\n\t\t\t\t\t})}\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nconst genInitialGrid = (start, target) => {\n\tconst grid = []\n\tfor (let i = 0; i < TOTAL_ROWS; ++i) {\n\t\tconst row = []\n\t\tfor (let j = 0; j < TOTAL_COLS; ++j) {\n\t\t\trow.push(createNode(i, j, start, target))\n\t\t}\n\t\tgrid.push(row)\n\t}\n\treturn grid\n}\n\nconst getNewEndpoints = () => {\n\tvar start_row = getRandomInt(1, TOTAL_ROWS - 2)\n\tvar start_col = getRandomInt(1, TOTAL_COLS - 2)\n\tvar target_row = getRandomInt(1, TOTAL_ROWS - 2)\n\tvar target_col = getRandomInt(1, TOTAL_COLS - 2)\n\twhile (start_row == target_row && start_col == target_col) {\n\t\ttarget_row = getRandomInt(1, TOTAL_ROWS - 2)\n\t\ttarget_col = getRandomInt(1, TOTAL_COLS - 2)\n\t}\n\treturn { start_row, start_col, target_row, target_col }\n}\n\nconst getNewGrid = (start, target) => {\n\tconst grid = []\n\tfor (let i = 0; i < TOTAL_ROWS; ++i) {\n\t\tconst row = []\n\t\tfor (let j = 0; j < TOTAL_COLS; ++j) {\n\t\t\trow.push(getEmptyNode(i, j))\n\t\t\tif (\n\t\t\t\t(i == start[0] && j == start[1]) ||\n\t\t\t\t(i == target[0] && j == target[1])\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdocument.getElementById(`node-${i}-${j}`).className = 'node node-empty'\n\t\t}\n\t\tgrid.push(row)\n\t}\n\tgrid[start[0]][start[1]].isStart = true\n\tgrid[target[0]][target[1]].isTarget = true\n\n\treturn grid\n}\n\nconst getMaze = (start, target, algorithm) => {\n\tconst grid = getNewGrid(start, target)\n\tconst walls = algorithm(TOTAL_ROWS, TOTAL_COLS, start, target)\n\tfor (let i = 0; i < TOTAL_ROWS; ++i) {\n\t\tfor (let j = 0; j < TOTAL_COLS; ++j) {\n\t\t\tif (\n\t\t\t\t(i == start[0] && j == start[1]) ||\n\t\t\t\t(i == target[0] && j == target[1])\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (walls[i][j]) {\n\t\t\t\ttoggleWall(grid, i, j, start, target)\n\t\t\t}\n\t\t}\n\t}\n\t// for (let i = 0; i < TOTAL_ROWS; ++i) {\n\t// \ttoggleWall(grid, i, 0)\n\t// \ttoggleWall(grid, i, TOTAL_COLS - 1)\n\t// }\n\t// for (let j = 0; j < TOTAL_COLS; ++j) {\n\t// \ttoggleWall(grid, 0, j)\n\t// \ttoggleWall(grid, TOTAL_ROWS - 1, j)\n\t// }\n\treturn grid\n}\n\nconst getEmptyNode = (row, col) => {\n\treturn {\n\t\trow,\n\t\tcol,\n\t\tisStart: false,\n\t\tisTarget: false,\n\t\tisVisited: false,\n\t\tisWall: false,\n\t\tpreviousNode: null\n\t}\n}\n\nconst createNode = (row, col, start, target) => {\n\treturn {\n\t\trow,\n\t\tcol,\n\t\tisStart: row == start[0] && col == start[1],\n\t\tisTarget: row == target[0] && col == target[1],\n\t\tisVisited: false,\n\t\tisWall: false,\n\t\tpreviousNode: null\n\t}\n}\n\nconst toggleWall = (grid, row, col) => {\n\tconst newGrid = grid.slice()\n\tconst node = newGrid[row][col]\n\tconst newNode = {\n\t\t...node,\n\t\tisWall: true\n\t}\n\tnewGrid[row][col] = newNode\n\treturn newGrid\n}\n\nfunction getRandomInt(min, max) {\n\tmin = Math.ceil(min)\n\tmax = Math.floor(max)\n\treturn Math.floor(Math.random() * (max - min + 1)) + min\n}\n\nexport default Grid\n","import React from 'react'\nimport { Button } from '@material-ui/core'\n\nexport default class Navstrip extends React.Component {\n\trender() {\n\t\treturn (\n\t\t\t<div className='rows'>\n\t\t\t\t<div className='row'>\n\t\t\t\t\t<h1>Pathfinder</h1>\n\t\t\t\t</div>\n\t\t\t\t<div className='row'>\n\t\t\t\t\t<Button>test</Button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t)\n\t}\n}\n","import React from 'react'\nimport { ThemeProvider } from '@material-ui/core/styles'\nimport { theme } from '../styles/mui_theme'\nimport Grid from './grid/grid'\nimport './App.css'\nimport Navstrip from './navstrip/navstrip'\n\nfunction App() {\n\treturn (\n\t\t<ThemeProvider theme={theme}>\n\t\t\t<Grid />\n\t\t</ThemeProvider>\n\t)\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './components/App'\nimport './index.css'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}